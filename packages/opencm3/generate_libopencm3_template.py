#!/bin/python3

#
# eChronos Real-Time Operating System
# Copyright (c) 2017, Commonwealth Scientific and Industrial Research
# Organisation (CSIRO) ABN 41 687 119 230.
#
# All rights reserved. CSIRO is willing to grant you a licence to the eChronos
# real-time operating system under the terms of the CSIRO_BSD_MIT license. See
# the file "LICENSE_CSIRO_BSD_MIT.txt" for details.
#
# @TAG(CSIRO_BSD_MIT)
#

import os
import os.path
import subprocess
import json

prx_template = """<?xml version="1.0" encoding="UTF-8" ?>
<system>
    <defines>{defines}
    </defines>
    <flags>{flags}
    </flags>
    <include_paths>{include_paths}
    </include_paths>
    <libraries>{libs}
    </libraries>
    <modules>
        <module name="armv7m.build" />
        <module name="armv7m.vectable">
            <flash_addr>{flash_addr}</flash_addr>
            <flash_size>{flash_size}</flash_size>
            <sram_size>{sram_addr}</sram_size>
            <sram_size>{sram_size}</sram_size>
            <include file="{extirq_prx}"/>
        </module>
        <module name="armv7m.semihost-debug" />
        <module name="generic.debug" />
        <!-- Add your project implementation files here -->
        <module name="{project_module}.ADDME" />
    </modules>
</system>"""

prx_extirq_template = """<?xml version="1.0" encoding="UTF-8" ?>
<external_irqs>{external_irqs}
</external_irqs> """

prx_define_template  = """\n        <define>{}</define>"""
prx_flag_template    = """\n        <flag>{}</flag>"""
prx_lib_template     = """\n        <library>{}</library>"""
prx_include_template = """\n        <include_path>{}</include_path>"""
prx_irq_template     = """
    <external_irq>
        <number>{}</number>
        <handler>{}_isr</handler>
    </external_irq>"""

readme_template = """# RTOS/libOpenCM3 project template for {part_name}

This project was automatically generated by {script_dir}

## Building

To build the project, `cd` to the root of the RTOS repository and run:

    $ prj/app/prj.py build {prj_dir}"""

this_file_path = os.path.abspath(os.path.realpath(__file__))
this_file_dir = os.path.abspath(os.path.dirname(this_file_path))
libopencm3_real_path = os.path.join(this_file_dir, "libopencm3")
this_file_dir_prj_relpath = os.path.join("packages", os.path.basename(this_file_dir))
libopencm3_prj_relpath = os.path.join(this_file_dir_prj_relpath, "libopencm3")

def ocm3_relpath_to_os_realpath(relpath):
    return os.path.join(libopencm3_real_path, relpath)

def ocm3_relpath_to_prj_relpath(relpath):
    return os.path.join(libopencm3_prj_relpath, relpath)

ocm3_genlink_relpath = "scripts/genlink.awk"
ocm3_ld_data_relpath = "ld/devices.data"
ocm3_libs_relpath = "lib/"
ocm3_include_relpath = "include/"

genlink_realpath = ocm3_relpath_to_os_realpath(ocm3_genlink_relpath)
ld_data_realpath = ocm3_relpath_to_os_realpath(ocm3_ld_data_relpath)

cortex_architectures = ['cortex-m0', 'cortex-m0plus', 'cortex-m3', 'cortex-m4', 'cortex-m7']
echronos_supported_architectures = ['cortex-m3', 'cortex-m4', 'cortex-m7']

def get_chip_details(chip, mode):
    awk_command = """awk -v PAT="{}" -v MODE="{}" -f {} {}""".format(chip, mode, genlink_realpath, ld_data_realpath)
    result = subprocess.run(awk_command,
            stdout=subprocess.PIPE, check=True, shell=True)
    return result.stdout.decode()

def find_irq_json_path(family):
    find_command = "find {} -name 'irq.json'".format(libopencm3_real_path)
    found_paths = subprocess.run(find_command, stdout=subprocess.PIPE,
                                    check=True, shell=True).stdout.decode().split()

    for found_path in found_paths:
        if family in os.path.relpath(found_path, libopencm3_real_path).replace("/",""):
            return found_path

find_irq_json_path("stm32f4")

def memory_size_string_to_int(size):
    postfixes = {
            'K': 1024,
            'M': 1024*1024,
            }

    if size[-1] in '0123456789':
        return int(size)
    else:
        if size[-1] in postfixes.keys():
            return int(size[:-1]) * postfixes[size[-1]]
        else:
            print("Unknown postfix on memory size?!")
            return 0

def generate_project_for_part(part):
    part_family    = get_chip_details(part, 'FAMILY')
    part_subfamily = get_chip_details(part, 'SUBFAMILY')
    part_cpu       = get_chip_details(part, 'CPU')
    part_fpu       = get_chip_details(part, 'FPU')
    part_cppflags  = get_chip_details(part, 'CPPFLAGS')
    part_defs      = get_chip_details(part, 'DEFS')

    if len(part_family) == 0:
        print("Part not in libopencm3 database")
        return

    arch_flags = ['-mcpu={}'.format(part_cpu)]

    if part_cpu not in echronos_supported_architectures:
        print("CPU architecture '{}' is not currently supported by the RTOS".format(part_cpu))
        return

    arch_flags += ['-mthumb']

    if part_fpu == "soft":
        arch_flags += ["-msoft_float"]
    elif part_fpu == "hard-fpv4-sp-d16":
        arch_flags += ["-mfloat-abi=hard", "-mfpu=fpv4-sp-d16"]
    elif part_fpu == "hard-fpv5-sp-d16":
        arch_flags += ["-mfloat-abi=hard", "-mfpu=fpv5-sp-d16"]
    else:
        print("Nonstandard FPU flag?")
        return

    part_family_lib_relpath = os.path.join(ocm3_libs_relpath,"libopencm3_{}.a".format(part_family))
    part_subfamily_lib_relpath = os.path.join(ocm3_libs_relpath,"libopencm3_{}.a".format(part_subfamily))

    libraries = []

    if os.path.isfile(ocm3_relpath_to_os_realpath(part_family_lib_relpath)):
        libraries += [ocm3_relpath_to_prj_relpath(part_family_lib_relpath)]
    elif os.path.isfile(ocm3_relpath_to_os_realpath(part_subfamily_lib_relpath)):
        libraries += [ocm3_relpath_to_prj_relpath(part_subfamily_lib_relpath)]
    else:
        print(("Library variant (i.e '{}') does not exist for this device.\n"
               "If this is a clean installation, ensure libopencm3 has been built")
               .format(ocm3_relpath_to_os_realpath(part_family_lib_relpath)))
        return

    part_properties = dict([p[3:].split('=') for p in part_defs.split() if p[:3] == "-D_"])
    part_rom_size = '{0:#010x}'.format(memory_size_string_to_int(part_properties['ROM']))
    part_ram_size = '{0:#010x}'.format(memory_size_string_to_int(part_properties['RAM']))
    part_rom_off = part_properties['ROM_OFF']
    part_ram_off = part_properties['RAM_OFF']

    print((
        "Fetching part details for {}:\n"
        "Part family:    {}\n"
        "Part subfamily: {}\n"
        "Part CPU:       {}\n"
        "Part FPU:       {}\n"
        "Part ROM size:  {}\n"
        "Part ROM offs.: {}\n"
        "Part RAM size:  {}\n"
        "Part RAM offs.: {}\n"
        "Extra flags:    {}\n"
        "Arch flags:     {}\n"
        "Libraries:      {}\n"
        "Raw defines:    {}\n").format(
            part, part_family, part_subfamily, part_cpu, part_fpu,
            part_rom_size, part_rom_off, part_ram_size, part_ram_off,
            part_cppflags, arch_flags, libraries, part_defs))

    includes = [ocm3_relpath_to_prj_relpath(ocm3_include_relpath)]

    all_defines = ''.join([prx_define_template.format(d[2:]) for d in part_cppflags.split()])
    all_flags = ''.join([prx_flag_template.format(f) for f in arch_flags])
    all_libs = ''.join([prx_lib_template.format(l) for l in libraries])
    all_includes = ''.join([prx_include_template.format(i) for i in includes])

    # GENERATE IRQ LINKAGES FOR VECTOR TABLE

    irq_json_path = find_irq_json_path(part_family)
    all_extirqs = ''
    with open(irq_json_path) as irq_file:
        irq_data = json.load(irq_file)
        irq2name = list(enumerate(irq_data['irqs'])
                        if isinstance(irq_data['irqs'], list)
                        else irq_data['irqs'].items())
        irqnames = [v for (k,v) in irq2name]

        all_extirqs = "".join(prx_irq_template.format(k, v) for (k,v) in irq2name)

    # BEGIN CREATING PROJECT FILES

    project_name = part

    output_dir = os.path.join(this_file_dir, "{}-project".format(project_name))

    prx_filename = "{}-system.prx".format(project_name)
    prx_extirq_filename = "{}-extirqs.prx".format(project_name)

    try:
        os.mkdir(output_dir)
    except FileExistsError:
        print("Directory {} already exists. Please delete or specify an alternate name for this template."
                .format(output_dir))
        return

    def path_to_prj_module(path):
        path_no_ext = os.path.splitext(path)[0]
        return path_no_ext.replace("/",".")

    prj_project_dir = os.path.join(this_file_dir_prj_relpath, os.path.basename(output_dir))
    prj_system_module = path_to_prj_module(os.path.join(prj_project_dir, prx_filename))
    prj_project_module = path_to_prj_module(prj_project_dir)

    prj_extirq_path = os.path.join(prj_project_dir, prx_extirq_filename)

    with open(os.path.join(output_dir, prx_filename), "w") as prx_file:
        prx_file.write(prx_template.format(
            defines=all_defines, flags=all_flags, libs=all_libs, include_paths=all_includes,
            flash_addr=part_rom_off, flash_size=part_rom_size, sram_addr=part_ram_off,
            sram_size=part_ram_size, project_module=prj_project_module, extirq_prx=prj_extirq_path))

    with open(os.path.join(output_dir, "README.md"), "w") as readme_file:
        readme_file.write(readme_template.format(
            part_name=part, script_dir=this_file_path, prj_dir=prj_system_module))

    with open(os.path.join(output_dir, prx_extirq_filename), "w") as prx_extirq_file:
        prx_extirq_file.write(prx_extirq_template.format(external_irqs=all_extirqs))

    print("**PROJECT GENERATION COMPLETE**")

generate_project_for_part('stm32f407VGT6')
