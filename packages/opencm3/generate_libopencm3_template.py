#!/bin/python3

#
# eChronos Real-Time Operating System
# Copyright (c) 2017, Commonwealth Scientific and Industrial Research
# Organisation (CSIRO) ABN 41 687 119 230.
#
# All rights reserved. CSIRO is willing to grant you a licence to the eChronos
# real-time operating system under the terms of the CSIRO_BSD_MIT license. See
# the file "LICENSE_CSIRO_BSD_MIT.txt" for details.
#
# @TAG(CSIRO_BSD_MIT)
#

import os
import os.path
import subprocess
import json
import argparse
from lxml import etree as ET

RTOS_TEMPLATES = {
    "acamar": {
            "irq_stubs": ["nmi", "hardfault", "memmanage", "busfault", "usagefault",
                          "svcall", "debug_monitor", "pendsv", "systick"],
            "additional_modules": ["armv7m.ctxt-switch"]
        }
    }

def construct_prx(data):

    def addEntriesTo(node, data_key, node_name):
        for e in data[data_key]:
            el = ET.SubElement(node, node_name)
            el.text = e

    system = ET.Element('system')

    defines = ET.SubElement(system, 'defines')
    addEntriesTo(defines, 'defines', 'define')

    flags = ET.SubElement(system, 'flags')
    addEntriesTo(flags, 'cflags', 'flag')

    include_paths = ET.SubElement(system, 'include_paths')
    addEntriesTo(include_paths, 'incpaths', 'include_path')

    libraries = ET.SubElement(system, 'libraries')
    addEntriesTo(libraries, 'libs', 'library')

    modules = ET.SubElement(system, 'modules')

    def addModule(module_name):
        return ET.SubElement(modules, "module", name=module_name)

    addModule('armv7m.build')
    vectable = addModule('armv7m.vectable')
    addModule('armv7m.semihost-debug')
    addModule('generic.debug')

    ET.SubElement(vectable, "flash_addr").text = data['rom_off']
    ET.SubElement(vectable, "flash_size").text = data['rom_size']
    ET.SubElement(vectable, "sram_addr").text = data['ram_off']
    ET.SubElement(vectable, "sram_size").text = data['ram_size']
    ET.SubElement(vectable, "include", file=data['extirq_dir'])

    stub = addModule(data['module_prx_prefix'] + '.ADDME')
    stub.addprevious(ET.Comment('Modify the below lines to add your own source'))

    return ET.tostring(system, pretty_print=True, xml_declaration=True, encoding='UTF-8').decode()

def construct_irq_prx(data):
    incroot = ET.Element('include_root')
    extirqs = ET.SubElement(incroot, 'external_irqs')

    def addIRQ(handler, number):
        e = ET.SubElement(extirqs, "external_irq")
        n = ET.SubElement(e, "number")
        h = ET.SubElement(e, "handler")
        n.text = number
        h.text = handler + "_isr"

    for (k, v) in data['irq2name']:
        addIRQ(str(v), str(k))

    return ET.tostring(incroot, pretty_print=True, xml_declaration=True, encoding='UTF-8').decode()

readme_template = """# RTOS/libOpenCM3 project template for {part_name}

This project was automatically generated by `{script_dir}`

## Building

To build the project, `cd` to the root of the RTOS repository and run:

    $ prj/app/prj.py build {prj_dir}"""

this_file_path = os.path.abspath(os.path.realpath(__file__))
this_file_dir = os.path.abspath(os.path.dirname(this_file_path))
libopencm3_real_path = os.path.join(this_file_dir, "libopencm3")
this_file_dir_prj_relpath = os.path.join("packages", os.path.basename(this_file_dir))
libopencm3_prj_relpath = os.path.join(this_file_dir_prj_relpath, "libopencm3")

def ocm3_relpath_to_os_realpath(relpath):
    return os.path.join(libopencm3_real_path, relpath)

def ocm3_relpath_to_prj_relpath(relpath):
    return os.path.join(libopencm3_prj_relpath, relpath)

ocm3_genlink_relpath = "scripts/genlink.awk"
ocm3_ld_data_relpath = "ld/devices.data"
ocm3_libs_relpath = "lib/"
ocm3_include_relpath = "include/"

genlink_realpath = ocm3_relpath_to_os_realpath(ocm3_genlink_relpath)
ld_data_realpath = ocm3_relpath_to_os_realpath(ocm3_ld_data_relpath)

cortex_architectures = ['cortex-m0', 'cortex-m0plus', 'cortex-m3', 'cortex-m4', 'cortex-m7']
echronos_supported_architectures = ['cortex-m3', 'cortex-m4', 'cortex-m7']

def get_chip_detail(chip, mode):
    awk_command = """awk -v PAT="{}" -v MODE="{}" -f {} {}""".format(chip, mode, genlink_realpath, ld_data_realpath)
    result = subprocess.run(awk_command,
            stdout=subprocess.PIPE, check=True, shell=True)
    return result.stdout.decode()

def get_chip_details(part):
    fields = ['FAMILY', 'SUBFAMILY', 'CPU', 'FPU', 'CPPFLAGS', 'DEFS']
    details = {}

    for field in fields:
        details[field] = get_chip_detail(part, field)

    # See if we actually got any data
    if len(details['FAMILY']) == 0:
        return None

    part_properties = dict([p[3:].split('=') for p in details['DEFS'].split() if p[:3] == "-D_"])

    details['ROM_SIZE'] = '{0:#010x}'.format(memory_size_string_to_int(part_properties['ROM']))
    details['RAM_SIZE'] = '{0:#010x}'.format(memory_size_string_to_int(part_properties['RAM']))
    details['ROM_OFF'] = part_properties['ROM_OFF']
    details['RAM_OFF'] = part_properties['RAM_OFF']

    return details

def find_irq_json_path(family):
    find_command = "find {} -name 'irq.json'".format(libopencm3_real_path)
    found_paths = subprocess.run(find_command, stdout=subprocess.PIPE,
                                    check=True, shell=True).stdout.decode().split()

    for found_path in found_paths:
        if family in os.path.relpath(found_path, libopencm3_real_path).replace("/",""):
            return found_path

find_irq_json_path("stm32f4")

def memory_size_string_to_int(size):
    postfixes = {
            'K': 1024,
            'M': 1024*1024,
            }

    if size[-1] in '0123456789':
        return int(size)
    else:
        if size[-1] in postfixes.keys():
            return int(size[:-1]) * postfixes[size[-1]]
        else:
            print("Unknown postfix on memory size?!")
            return 0

def generate_project_for_part(part, project_name):

    chip_details = get_chip_details(part)

    if chip_details == None:
        print("Part not in libopencm3 database")
        return

    arch_flags = ['-mcpu={CPU}'.format(**chip_details)]

    if chip_details['CPU'] not in echronos_supported_architectures:
        print("CPU architecture '{}' is not currently supported by the RTOS".format(part_cpu))
        return

    arch_flags += ['-mthumb']

    if chip_details['FPU'] == "soft":
        arch_flags += ["-msoft_float"]
    elif chip_details['FPU'] == "hard-fpv4-sp-d16":
        arch_flags += ["-mfloat-abi=hard", "-mfpu=fpv4-sp-d16"]
    elif chip_details['FPU'] == "hard-fpv5-sp-d16":
        arch_flags += ["-mfloat-abi=hard", "-mfpu=fpv5-sp-d16"]
    else:
        print("Nonstandard FPU flag?")
        return

    part_family_lib_relpath = os.path.join(
            ocm3_libs_relpath,"libopencm3_{}.a".format(chip_details['FAMILY']))
    part_subfamily_lib_relpath = os.path.join(
            ocm3_libs_relpath,"libopencm3_{}.a".format(chip_details['SUBFAMILY']))

    libraries = []

    if os.path.isfile(ocm3_relpath_to_os_realpath(part_family_lib_relpath)):
        libraries += [ocm3_relpath_to_prj_relpath(part_family_lib_relpath)]
    elif os.path.isfile(ocm3_relpath_to_os_realpath(part_subfamily_lib_relpath)):
        libraries += [ocm3_relpath_to_prj_relpath(part_subfamily_lib_relpath)]
    else:
        print(("Library variant (i.e '{}') does not exist for this device.\n"
               "If this is a clean installation, ensure libopencm3 has been built")
               .format(ocm3_relpath_to_os_realpath(part_family_lib_relpath)))
        return

    print((
        "Fetching part details for {part_searched}:\n"
        "Part family:    {FAMILY}\n"
        "Part subfamily: {SUBFAMILY}\n"
        "Part CPU:       {CPU}\n"
        "Part FPU:       {FPU}\n"
        "Part ROM size:  {ROM_SIZE}\n"
        "Part ROM offs.: {ROM_OFF}\n"
        "Part RAM size:  {RAM_SIZE}\n"
        "Part RAM offs.: {RAM_OFF}\n"
        "Extra flags:    {CPPFLAGS}\n"
        "Arch flags:     {aflags}\n"
        "Libraries:      {libs}\n"
        "Raw defines:    {DEFS}\n").format(
            part_searched=part, aflags=arch_flags, libs=libraries,
            **chip_details))

    includes = [ocm3_relpath_to_prj_relpath(ocm3_include_relpath)]

    # GENERATE IRQ LINKAGES FOR VECTOR TABLE

    irq_json_path = find_irq_json_path(chip_details['FAMILY'])
    irq2name = []
    with open(irq_json_path) as irq_file:
        irq_data = json.load(irq_file)
        irq2name = list(enumerate(irq_data['irqs'])
                        if isinstance(irq_data['irqs'], list)
                        else irq_data['irqs'].items())

    # SET UP PROJECT DIRECTORIES

    output_dir = os.path.join(this_file_dir, "{}-project".format(project_name))

    prx_filename = "{}-system.prx".format(project_name)
    prx_extirq_filename = "{}-extirqs.prx".format(project_name)

    try:
        os.mkdir(output_dir)
    except FileExistsError:
        print("Directory {} already exists. Please delete or specify an alternate name for this template."
                .format(output_dir))
        return

    def path_to_prj_module(path):
        path_no_ext = os.path.splitext(path)[0]
        return path_no_ext.replace("/",".")

    prj_project_dir = os.path.join(this_file_dir_prj_relpath, os.path.basename(output_dir))
    prj_project_reldir = os.path.join(os.path.basename(this_file_dir), os.path.basename(output_dir))
    prj_system_module = path_to_prj_module(os.path.join(prj_project_reldir, prx_filename))
    prj_project_module = path_to_prj_module(prj_project_reldir)

    prj_extirq_path = os.path.join(prj_project_dir, prx_extirq_filename)

    # START PREPARING DATA FOR WRITING

    prx_data = {}
    prx_data['defines'] = [d[2:] for d in chip_details['CPPFLAGS'].split()]
    prx_data['cflags'] = arch_flags
    prx_data['libs'] = libraries
    prx_data['incpaths'] = includes
    prx_data['rom_off'] = chip_details['ROM_OFF']
    prx_data['ram_off'] = chip_details['RAM_OFF']
    prx_data['rom_size'] = chip_details['ROM_SIZE']
    prx_data['ram_size'] = chip_details['RAM_SIZE']
    prx_data['module_prx_prefix'] = prj_project_module
    prx_data['extirq_dir'] = os.path.basename(prj_extirq_path)

    prx_irq_data = {}
    prx_irq_data['irq2name'] = irq2name

    # WRITE FILES

    with open(os.path.join(output_dir, prx_filename), "w") as prx_file:
        prx_file.write(construct_prx(prx_data))

    with open(os.path.join(output_dir, prx_extirq_filename), "w") as prx_extirq_file:
        prx_extirq_file.write(construct_irq_prx(prx_irq_data))

    with open(os.path.join(output_dir, "README.md"), "w") as readme_file:
        readme_file.write(readme_template.format(
            part_name=part, script_dir=os.path.basename(this_file_path), prj_dir=prj_system_module))

    print("**PROJECT GENERATION COMPLETE**")


parser = argparse.ArgumentParser(description='Generate an eChronos / libopencm3 project template.')

parser.add_argument('part_id', help='Chip ID to generate a project for')
parser.add_argument('--project_name', default=None, help='What to name the project.')

args = parser.parse_args()

if args.project_name == None:
    args.project_name = args.part_id

generate_project_for_part(args.part_id, args.project_name)
