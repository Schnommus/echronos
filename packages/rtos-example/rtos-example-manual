%title RTOS Example package: user manual
%version 1-draft
%docid ApE1iw

Introduction
-------------

The RTOS Example package contains the code for a number of RTOS example programs:

kochab-signal-demo
  ~ An example C program demonstrating signal functionality on the kochab variant.
kochab-mutex-demo
  ~ An example C program demonstrating mutex functionality on the kochab variant.
kochab-sem-demo
  ~ An example C program demonstrating semaphore functionality on the kochab variant.


`kochab-signal-demo`
====================

This system demonstrates the eChronos/kochab signal functionality:

  Part 0 has one task (A) demonstrate peeking and polling of signals, as well as waits returning immediately if a signal in the set is already available.

  Part 1 shows a higher priority task (A) block waiting on a signal set, and being unblocked by a lower priority task (B) sending it signals in the set.
  Signals not in the set will not wake task (A), but will remain pending such that (A) will return immediately if it tries to wait on them subsequently.

There is no LED activity in this system, only debug prints via GDB.
The following is the expected output of the signal demo, continuing from a breakpoint set at `rtos_start`:

    (gdb) c
    Continuing.

    Part 0: Solo

    a: setting all signals
    a: peeking/polling specific signals
    a: checking for stray signals
    a: re-setting all signals
    a: peeking/polling specific signals in reverse order
    a: checking for stray signals
    a: re-setting all signals
    a: peeking/polling whole signal set
    a: checking for stray signals
    a: re-setting all signals
    a: waiting on specific signals (should not block)
    a: checking for stray signals
    a: re-setting all signals
    a: waiting on specific signals in reverse order (should not block)
    a: checking for stray signals
    a: re-setting all signals
    a: waiting on signal set (should not block)
    a: checking for stray signals

    Part 1: B unblocks A

    a: waiting on signal set
    b: sending specific signal to a
    a: checking for stray signals
    a: waiting on specific signal
    b: sending whole signal set to a
    a: got specific signal
    a: gathering up all other signals b sent (should not block)
    a: checking for stray signals
    a: waiting on specific signal
    b: sending signals that shouldn't wake up a
    b: sending signal to wake up a
    a: got specific signal
    a: gathering up all other signals b sent (should not block)
    a: checking for stray signals

    Done.


`kochab-mutex-demo`
===================

This system demonstrates the eChronos/kochab mutex functionality:

  Part 0 has one task (A) demonstrate trying and releasing of a mutex, as well as taking of a mutex when the mutex is available.

  Part 1 shows a lower priority task (B) unblocking a higher priority task (A) by releasing a mutex it is blocked waiting on.

  Part 2 demonstrates the lowest-priority task (Z) inheriting the priority of the highest priority task (A), due to task (Z) holding a mutex that task (A) is blocked waiting on.
  Thus, task (Z) is scheduled over tasks (B) and (Y), despite them normally having a priority higher than task (Z).

  Part 3 demonstrates that priority inheritance is transitive.
  Task (A) is blocked by one mutex held by task (Y), and task (Y) is blocked by another mutex held by task (Z).
  Therefore, task (Z) inherits the priority of task (A) via task (Y), and is thus scheduled ahead of task (B), even though task (B) normally has a higher priority than both (Y) and (Z).

  Part 4 demonstrates that if two tasks (B) and (Y) are both waiting to acquire a mutex, the higher-priority task (B) will be given ownership of the mutex in preference to the lower-priority task (Y).

  Part 5 demonstrates that the higher-priority task (B) will be given preference over the lower priority task (Y) regardless of which of the two tasks attempted to acquire the mutex first.

There is no LED activity in this system, only debug prints via GDB.
The following is the expected output of the mutex demo, continuing from a breakpoint set at `rtos_start`:

    (gdb) c
    Continuing.

    Part 0: Solo

    a: taking lock
    a: trying held lock
    a: releasing lock
    a: trying unheld lock
    a: releasing lock

    Part 1: B unblocks A

    a: waiting on signal
    b: taking lock
    b: sending signal to a
    a: got signal, waiting on lock
    b: now runnable. releasing lock
    a: got lock, releasing lock

    Part 2: Z inherits from A, over B and Y

    a: waiting on signal
    b: waiting on signal
    y: waiting on signal
    z: taking lock
    z: sending signal to y
    y: got signal, now y is runnable. sending signal to b
    b: got signal, now b is runnable. sending signal to a
    a: got signal, waiting on lock
    z: inherited priority from a, over b and y. releasing lock
    a: got lock, releasing lock

    Part 3: Z inherits from A via Y, over B

    a: waiting on signal
    b: waiting on signal
    y: waiting on signal
    z: taking 2nd lock
    z: sending signal to y
    y: got signal, grabbing 1st lock
    y: sending signal to b
    b: got signal, now b is runnable. sending signal to a
    a: got signal, waiting on 1st lock
    y: inherited priority from a, over b. now waiting on 2nd lock
    z: inherited priority from a via y, over b. releasing 2nd lock
    y: got 2nd lock, releasing it
    y: releasing 1st lock
    a: got 1st lock, releasing it

    Part 4: B and Y compete. B tries to acquire first

    a: taking the lock
    a: waiting on signal
    b: blocking on the lock
    y: blocking on the lock
    z: sending signal to a
    a: releasing the lock
    a: taking the lock again
    a: should still be running, with the lock. releasing it
    a: waiting on signal to let new lock holder run
    b: should get the lock before y does. releasing it
    b: blocking again on the lock
    b: should still be running, with the lock. releasing it
    b: waiting on signal to let lock holder run
    y: should be the last task to get the lock. releasing it
    y: sending signal to b
    b: sending signal to a

    Part 5: B and Y compete. Y tries to acquire first

    a: taking the lock
    a: waiting on signal
    b: waiting on signal to let y go first
    y: blocking on the lock
    z: sending signal to b
    b: blocking on the lock
    z: sending signal to a
    a: releasing the lock
    a: waiting on signal to let new lock holder run
    b: should still get the lock before y does. releasing it
    b: waiting on signal to let lock holder run
    y: should be the last task to get the lock. releasing it
    y: sending signal to b
    b: sending signal to a

    Done.


`kochab-sem-demo`
=================

This system demonstrates the eChronos/kochab semaphore functionality:

  Part 0 has one task (A) demonstrate posting (denoted `V`) and trying to wait (denoted `P`) on a semaphore, as well as returning immediately from waiting on a semaphore that has already been posted.

  Part 1 has a lower-priority task (B) unblock a higher-priority task (A) by posting to a semaphore that task (A) is blocked waiting on.
  It also shows the basic property of semaphores that (A) can only wait the same number of times (B) has posted to the semaphore, before a wait attempt would block (A).

  Part 2 shows that if two tasks are both blocked waiting on a semaphore, the higher priority task (A) will be woken in preference to the lower priority task (B) when some other task (Z) posts to the semaphore, regardless of whether task (A) or task (B) attempted to wait on the semaphore first.

  Part 3 demonstrates that if the user posts to the semaphore more times than the runtime-initialized maximum value, the RTOS will trigger a fatal error.

There is no LED activity in this system, only debug prints via GDB.
The following is the expected output of the semaphore demo, continuing from a breakpoint set at `rtos_start`:

    (gdb) c
    Continuing.

    Part 0: Solo

    a: initializing maximum
    a: V
    a: P (should succeed)
    a: trying P (should fail)
    a: V
    a: trying P (should succeed)

    Part 1: B unblocks A

    a: P (should block)
    b: V (should unblock a)
    a: now runnable
    a: consuming...
    a: P
    b: producing while a consumes...
    b: V
    a: P
    b: V
    a: P
    b: V
    a: P
    b: V
    a: P
    b: V
    a: P
    b: V
    a: P
    b: V
    a: P
    b: V
    a: P
    b: V
    a: P
    b: V
    a: trying P (should fail)
    a: waiting on signal
    b: producing while a is blocked...
    b: V
    b: V
    b: V
    b: V
    b: V
    b: V
    b: V
    b: V
    b: V
    b: V
    b: sending signal to a
    a: consuming...
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: trying P (should fail)

    Part 2: A and B compete

    a: P (should block)
    b: P (should block)
    z: V
    a: should wake up before b. P (should block)
    z: V
    a: should again wake up before b. waiting on signal
    z: V
    b: finally awake. sending signal to a

    Part 3: A posts past maximum and triggers fatal error

    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: P
    a: trying P (should trigger fatal error)
    FATAL ERROR: <hexadecimal error code for ERROR_ID_SEMAPHORE_MAX_EXCEEDED - see rtos-variant.h>
